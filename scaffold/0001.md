# OnePromptOS Implementation Scaffold
## Technical Architecture & Module Specifications (v0.1)

---

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Project Structure](#project-structure)
3. [Core Modules](#core-modules)
4. [TypeScript Interfaces](#typescript-interfaces)
5. [Implementation Modules](#implementation-modules)
6. [Example Capabilities](#example-capabilities)
7. [Configuration](#configuration)
8. [Deployment Considerations](#deployment-considerations)

---

## Architecture Overview

### System Layers

```
┌─────────────────────────────────────────────────────────┐
│                    Shell (UI Layer)                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ Prompt Bar   │  │ Action Strip │  │ Canvas       │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
                          ↕
┌─────────────────────────────────────────────────────────┐
│              Orchestration Layer                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │IntentRouter  │→ │Orchestrator  │→ │MomentStore   │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
                          ↕
┌─────────────────────────────────────────────────────────┐
│              Capability Layer                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │Capability    │  │Policy        │  │Audit         │  │
│  │Registry      │  │Engine        │  │Logger        │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
                          ↕
┌─────────────────────────────────────────────────────────┐
│              Substrate (Data/Services)                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │State Store   │  │External APIs │  │Event Bus     │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
```

---

## Project Structure

```
oneprompt-os/
├── packages/
│   ├── core/                      # Framework core
│   │   ├── src/
│   │   │   ├── types/             # TypeScript type definitions
│   │   │   ├── runtime/           # Runtime engine
│   │   │   ├── intent/            # Intent router
│   │   │   ├── orchestrator/      # Orchestration layer
│   │   │   ├── moment/            # Moment management
│   │   │   ├── capability/        # Capability system
│   │   │   ├── policy/            # Policy engine
│   │   │   └── index.ts
│   │   ├── tests/
│   │   └── package.json
│   │
│   ├── shell/                     # UI Shell
│   │   ├── src/
│   │   │   ├── components/
│   │   │   │   ├── PromptBar/
│   │   │   │   ├── ActionStrip/
│   │   │   │   └── Canvas/
│   │   │   ├── renderers/
│   │   │   └── index.tsx
│   │   └── package.json
│   │
│   ├── capabilities/              # Standard capabilities
│   │   ├── src/
│   │   │   ├── filesystem/
│   │   │   ├── network/
│   │   │   ├── database/
│   │   │   └── compute/
│   │   └── package.json
│   │
│   └── cli/                       # CLI tool
│       ├── src/
│       └── package.json
│
├── apps/
│   ├── web/                       # Web app
│   ├── desktop/                   # Electron app
│   └── mobile/                    # React Native app
│
├── examples/
│   ├── todo-app/
│   ├── file-manager/
│   └── data-explorer/
│
├── docs/
│   ├── architecture/
│   ├── api/
│   └── guides/
│
└── package.json
```

---

## Core Modules

### 1. Moment System

**Purpose**: Manages ephemeral interaction states

```typescript
// packages/core/src/moment/Moment.ts

export interface Moment {
  moment_id: string;
  timestamp: number;
  focus: Focus;
  canvas_frame: CanvasFrame;
  action_set: Action[];
  summary_line: string;
  risk_state: RiskState;
  audit_hint: string;
  parent_moment_id?: string;
}

export interface Focus {
  type: 'root' | 'task' | 'entity' | 'confirmation';
  entity_id?: string;
  task_name?: string;
  breadcrumb: string[];
}

export interface CanvasFrame {
  renderer: string;
  data: unknown;
  viewport_hint?: ViewportHint;
}

export type RiskState = 'SAFE' | 'CONFIRM' | 'DANGEROUS';

export interface ViewportHint {
  width?: number;
  height?: number;
  theme?: 'light' | 'dark' | 'auto';
}
```

**MomentStore Implementation**:

```typescript
// packages/core/src/moment/MomentStore.ts

export class MomentStore {
  private moments: Map<string, Moment> = new Map();
  private history: string[] = [];
  private currentIndex: number = -1;
  
  create(moment: Omit<Moment, 'moment_id' | 'timestamp'>): Moment {
    const newMoment: Moment = {
      ...moment,
      moment_id: this.generateId(),
      timestamp: Date.now()
    };
    
    this.moments.set(newMoment.moment_id, newMoment);
    
    // Truncate forward history on new moment
    this.history = this.history.slice(0, this.currentIndex + 1);
    this.history.push(newMoment.moment_id);
    this.currentIndex++;
    
    return newMoment;
  }
  
  getCurrent(): Moment | null {
    if (this.currentIndex < 0) return null;
    const momentId = this.history[this.currentIndex];
    return this.moments.get(momentId) || null;
  }
  
  canGoBack(): boolean {
    return this.currentIndex > 0;
  }
  
  back(): Moment | null {
    if (!this.canGoBack()) return null;
    this.currentIndex--;
    return this.getCurrent();
  }
  
  canGoForward(): boolean {
    return this.currentIndex < this.history.length - 1;
  }
  
  forward(): Moment | null {
    if (!this.canGoForward()) return null;
    this.currentIndex++;
    return this.getCurrent();
  }
  
  getHistory(limit: number = 10): Moment[] {
    return this.history
      .slice(Math.max(0, this.currentIndex - limit), this.currentIndex)
      .map(id => this.moments.get(id))
      .filter((m): m is Moment => m !== undefined);
  }
  
  private generateId(): string {
    return `moment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

---

### 2. Action System

**Purpose**: Defines executable operations with safety metadata

```typescript
// packages/core/src/types/Action.ts

export interface Action {
  label: string;
  action_id: string;
  args?: Record<string, unknown>;
  tier: ActionTier;
  speech_alias?: string;
  requires_focus?: string;
  undoable: boolean;
  telemetry_tag?: string;
  icon?: string;
  variant?: 'primary' | 'secondary' | 'danger' | 'neutral';
}

export type ActionTier = 'SAFE' | 'CONFIRM' | 'DANGEROUS';

export interface ActionResult {
  success: boolean;
  next_moment?: Moment;
  error?: ActionError;
  audit_log?: AuditEntry;
}

export interface ActionError {
  code: string;
  message: string;
  recoverable: boolean;
  suggested_actions?: Action[];
}
```

---

### 3. Intent Router

**Purpose**: Parses user input and determines intent

```typescript
// packages/core/src/intent/IntentRouter.ts

export interface Intent {
  goal: string;
  entities: Entity[];
  missing_slots: Slot[];
  confidence: number;
  candidate_actions: Action[];
  clarification_needed?: string;
}

export interface Entity {
  type: string;
  value: unknown;
  span?: [number, number];
}

export interface Slot {
  name: string;
  type: string;
  required: boolean;
  prompt: string;
}

export class IntentRouter {
  private nlpProvider: NLPProvider;
  private capabilityRegistry: CapabilityRegistry;
  
  constructor(nlpProvider: NLPProvider, capabilityRegistry: CapabilityRegistry) {
    this.nlpProvider = nlpProvider;
    this.capabilityRegistry = capabilityRegistry;
  }
  
  async route(input: string, context: Context): Promise<Intent> {
    // 1. Parse input
    const parsed = await this.nlpProvider.parse(input);
    
    // 2. Extract entities
    const entities = this.extractEntities(parsed);
    
    // 3. Match to capabilities
    const matches = this.capabilityRegistry.findMatches(parsed.intent, entities);
    
    // 4. Identify missing slots
    const missing_slots = this.identifyMissingSlots(matches, entities);
    
    // 5. Generate candidate actions
    const candidate_actions = this.generateActions(matches, entities);
    
    // 6. Determine if clarification needed
    const clarification_needed = missing_slots.length > 0 
      ? missing_slots[0].prompt 
      : undefined;
    
    return {
      goal: parsed.intent,
      entities,
      missing_slots,
      confidence: parsed.confidence,
      candidate_actions,
      clarification_needed
    };
  }
  
  private extractEntities(parsed: ParsedInput): Entity[] {
    // Implementation depends on NLP provider
    return [];
  }
  
  private identifyMissingSlots(matches: Capability[], entities: Entity[]): Slot[] {
    // Check which required slots are missing
    return [];
  }
  
  private generateActions(matches: Capability[], entities: Entity[]): Action[] {
    // Generate action chips from capability matches
    return [];
  }
}

interface NLPProvider {
  parse(input: string): Promise<ParsedInput>;
}

interface ParsedInput {
  intent: string;
  confidence: number;
  raw: string;
}

interface Context {
  current_moment?: Moment;
  user_id: string;
  session_id: string;
}
```

---

### 4. Capability System

**Purpose**: Defines and executes operations with permissions and validation

```typescript
// packages/core/src/capability/Capability.ts

export interface Capability {
  name: string;
  version: string;
  description: string;
  input_schema: JSONSchema;
  output_schema: JSONSchema;
  permissions: Permission[];
  metadata: CapabilityMetadata;
  
  execute(input: unknown, context: ExecutionContext): Promise<CapabilityResult>;
  validate(input: unknown): ValidationResult;
  canUndo(): boolean;
  undo?(context: ExecutionContext): Promise<UndoResult>;
}

export interface CapabilityMetadata {
  category: string;
  tags: string[];
  risk_level: ActionTier;
  idempotent: boolean;
  estimated_duration_ms?: number;
}

export interface Permission {
  resource: string;
  action: 'read' | 'write' | 'execute' | 'delete';
  scope?: string;
}

export interface ExecutionContext {
  user_id: string;
  session_id: string;
  moment_id: string;
  permissions: Permission[];
  idempotency_key?: string;
}

export interface CapabilityResult {
  success: boolean;
  output?: unknown;
  error?: CapabilityError;
  side_effects: SideEffect[];
  duration_ms: number;
}

export interface SideEffect {
  type: 'state_change' | 'external_call' | 'file_write' | 'network_request';
  description: string;
  reversible: boolean;
}

export interface CapabilityError {
  code: string;
  message: string;
  details?: unknown;
}

export interface ValidationResult {
  valid: boolean;
  errors?: ValidationError[];
}

export interface ValidationError {
  field: string;
  message: string;
}

export interface UndoResult {
  success: boolean;
  error?: string;
}

type JSONSchema = Record<string, unknown>;
```

**CapabilityRegistry Implementation**:

```typescript
// packages/core/src/capability/CapabilityRegistry.ts

export class CapabilityRegistry {
  private capabilities: Map<string, Capability> = new Map();
  private index: CapabilityIndex = new CapabilityIndex();
  
  register(capability: Capability): void {
    const key = `${capability.name}@${capability.version}`;
    this.capabilities.set(key, capability);
    this.index.add(capability);
  }
  
  get(name: string, version: string = 'latest'): Capability | undefined {
    if (version === 'latest') {
      return this.getLatestVersion(name);
    }
    return this.capabilities.get(`${name}@${version}`);
  }
  
  findMatches(intent: string, entities: Entity[]): Capability[] {
    return this.index.search(intent, entities);
  }
  
  list(filter?: CapabilityFilter): Capability[] {
    const all = Array.from(this.capabilities.values());
    if (!filter) return all;
    
    return all.filter(cap => {
      if (filter.category && cap.metadata.category !== filter.category) {
        return false;
      }
      if (filter.tags && !filter.tags.some(t => cap.metadata.tags.includes(t))) {
        return false;
      }
      return true;
    });
  }
  
  private getLatestVersion(name: string): Capability | undefined {
    const matching = Array.from(this.capabilities.entries())
      .filter(([key]) => key.startsWith(`${name}@`))
      .map(([, cap]) => cap);
    
    if (matching.length === 0) return undefined;
    
    // Simple version comparison - could be enhanced
    return matching[matching.length - 1];
  }
}

interface CapabilityFilter {
  category?: string;
  tags?: string[];
}

class CapabilityIndex {
  private byIntent: Map<string, Set<string>> = new Map();
  private byEntity: Map<string, Set<string>> = new Map();
  
  add(capability: Capability): void {
    // Build searchable index
    // This is a simplified implementation
  }
  
  search(intent: string, entities: Entity[]): Capability[] {
    // Search index for matching capabilities
    return [];
  }
}
```

---

### 5. Orchestrator

**Purpose**: Coordinates execution flow and state management

```typescript
// packages/core/src/orchestrator/Orchestrator.ts

export class Orchestrator {
  private momentStore: MomentStore;
  private capabilityRegistry: CapabilityRegistry;
  private policyEngine: PolicyEngine;
  private auditLogger: AuditLogger;
  private eventBus: EventBus;
  
  constructor(
    momentStore: MomentStore,
    capabilityRegistry: CapabilityRegistry,
    policyEngine: PolicyEngine,
    auditLogger: AuditLogger,
    eventBus: EventBus
  ) {
    this.momentStore = momentStore;
    this.capabilityRegistry = capabilityRegistry;
    this.policyEngine = policyEngine;
    this.auditLogger = auditLogger;
    this.eventBus = eventBus;
  }
  
  async executeAction(
    action: Action,
    context: ExecutionContext
  ): Promise<ActionResult> {
    const startTime = Date.now();
    
    try {
      // 1. Policy check
      const policyCheck = await this.policyEngine.check(action, context);
      if (!policyCheck.allowed) {
        return {
          success: false,
          error: {
            code: 'POLICY_DENIED',
            message: policyCheck.reason || 'Action not allowed',
            recoverable: false
          }
        };
      }
      
      // 2. Get capability
      const capability = this.capabilityRegistry.get(action.action_id);
      if (!capability) {
        return {
          success: false,
          error: {
            code: 'CAPABILITY_NOT_FOUND',
            message: `Capability ${action.action_id} not found`,
            recoverable: false
          }
        };
      }
      
      // 3. Validate input
      const validation = capability.validate(action.args);
      if (!validation.valid) {
        return {
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Invalid input',
            recoverable: true,
            suggested_actions: this.generateCorrectionActions(validation)
          }
        };
      }
      
      // 4. Execute capability
      const result = await capability.execute(action.args, context);
      
      // 5. Create audit log
      const auditEntry: AuditEntry = {
        timestamp: Date.now(),
        user_id: context.user_id,
        action_id: action.action_id,
        input: action.args,
        output: result.output,
        duration_ms: Date.now() - startTime,
        success: result.success,
        side_effects: result.side_effects
      };
      
      await this.auditLogger.log(auditEntry);
      
      // 6. Emit events
      this.eventBus.emit('action:executed', {
        action,
        result,
        audit: auditEntry
      });
      
      // 7. Create next moment if needed
      if (result.success) {
        const nextMoment = await this.createNextMoment(action, result, context);
        return {
          success: true,
          next_moment: nextMoment,
          audit_log: auditEntry
        };
      }
      
      return {
        success: false,
        error: {
          code: result.error?.code || 'EXECUTION_ERROR',
          message: result.error?.message || 'Execution failed',
          recoverable: true
        },
        audit_log: auditEntry
      };
      
    } catch (error) {
      // Handle unexpected errors
      const auditEntry: AuditEntry = {
        timestamp: Date.now(),
        user_id: context.user_id,
        action_id: action.action_id,
        input: action.args,
        duration_ms: Date.now() - startTime,
        success: false,
        error: String(error)
      };
      
      await this.auditLogger.log(auditEntry);
      
      return {
        success: false,
        error: {
          code: 'UNEXPECTED_ERROR',
          message: 'An unexpected error occurred',
          recoverable: false
        },
        audit_log: auditEntry
      };
    }
  }
  
  private async createNextMoment(
    action: Action,
    result: CapabilityResult,
    context: ExecutionContext
  ): Promise<Moment> {
    // Generate next moment based on result
    const currentMoment = this.momentStore.getCurrent();
    
    // This would be more sophisticated in practice
    return this.momentStore.create({
      focus: currentMoment?.focus || { type: 'root', breadcrumb: [] },
      canvas_frame: {
        renderer: 'default',
        data: result.output
      },
      action_set: [],
      summary_line: `Executed ${action.label}`,
      risk_state: 'SAFE',
      audit_hint: `${action.label} completed successfully`,
      parent_moment_id: currentMoment?.moment_id
    });
  }
  
  private generateCorrectionActions(validation: ValidationResult): Action[] {
    // Generate actions to help user correct validation errors
    return [];
  }
}

interface AuditEntry {
  timestamp: number;
  user_id: string;
  action_id: string;
  input?: unknown;
  output?: unknown;
  duration_ms: number;
  success: boolean;
  error?: string;
  side_effects?: SideEffect[];
}
```

---

### 6. Policy Engine

**Purpose**: Enforces authorization and safety rules

```typescript
// packages/core/src/policy/PolicyEngine.ts

export interface Policy {
  name: string;
  version: string;
  evaluate(action: Action, context: ExecutionContext): Promise<PolicyResult>;
}

export interface PolicyResult {
  allowed: boolean;
  reason?: string;
  required_confirmation?: ConfirmationType;
}

export type ConfirmationType = 'tap' | 'long_press' | 'retype' | 'voice_confirm';

export class PolicyEngine {
  private policies: Policy[] = [];
  
  register(policy: Policy): void {
    this.policies.push(policy);
  }
  
  async check(action: Action, context: ExecutionContext): Promise<PolicyResult> {
    // Evaluate all policies
    for (const policy of this.policies) {
      const result = await policy.evaluate(action, context);
      if (!result.allowed) {
        return result;
      }
    }
    
    return { allowed: true };
  }
}

// Example policy: Rate limiting
export class RateLimitPolicy implements Policy {
  name = 'rate_limit';
  version = '1.0.0';
  
  private limits: Map<string, RateLimit> = new Map();
  
  async evaluate(action: Action, context: ExecutionContext): Promise<PolicyResult> {
    const key = `${context.user_id}:${action.action_id}`;
    const limit = this.limits.get(key);
    
    if (limit && limit.count >= limit.max) {
      const resetIn = limit.resetAt - Date.now();
      return {
        allowed: false,
        reason: `Rate limit exceeded. Try again in ${Math.ceil(resetIn / 1000)}s`
      };
    }
    
    // Update counter
    if (!limit) {
      this.limits.set(key, {
        count: 1,
        max: 100,
        resetAt: Date.now() + 60000 // 1 minute
      });
    } else {
      limit.count++;
    }
    
    return { allowed: true };
  }
}

interface RateLimit {
  count: number;
  max: number;
  resetAt: number;
}

// Example policy: Confirmation requirements
export class ConfirmationPolicy implements Policy {
  name = 'confirmation';
  version = '1.0.0';
  
  async evaluate(action: Action, context: ExecutionContext): Promise<PolicyResult> {
    switch (action.tier) {
      case 'SAFE':
        return { allowed: true };
      
      case 'CONFIRM':
        return {
          allowed: true,
          required_confirmation: 'tap'
        };
      
      case 'DANGEROUS':
        return {
          allowed: true,
          required_confirmation: 'long_press'
        };
      
      default:
        return { allowed: false, reason: 'Unknown action tier' };
    }
  }
}
```

---

## TypeScript Interfaces

Complete type definitions for the framework:

```typescript
// packages/core/src/types/index.ts

export * from './Moment';
export * from './Action';
export * from './Capability';
export * from './Policy';
export * from './Audit';
export * from './Event';

// Additional core types

export interface FrameworkConfig {
  nlp_provider?: string;
  persistence?: PersistenceConfig;
  telemetry?: TelemetryConfig;
  security?: SecurityConfig;
}

export interface PersistenceConfig {
  type: 'memory' | 'local' | 'remote';
  connection_string?: string;
}

export interface TelemetryConfig {
  enabled: boolean;
  endpoint?: string;
  sample_rate?: number;
}

export interface SecurityConfig {
  auth_provider: string;
  session_timeout_ms: number;
  require_confirmation_for: ActionTier[];
}

export interface EventBus {
  emit(event: string, data: unknown): void;
  on(event: string, handler: (data: unknown) => void): void;
  off(event: string, handler: (data: unknown) => void): void;
}

export interface AuditLogger {
  log(entry: AuditEntry): Promise<void>;
  query(filter: AuditFilter): Promise<AuditEntry[]>;
}

export interface AuditFilter {
  user_id?: string;
  action_id?: string;
  start_time?: number;
  end_time?: number;
  success?: boolean;
}
```

---

## Example Capabilities

### File System Capability

```typescript
// packages/capabilities/src/filesystem/ReadFileCapability.ts

import { Capability, CapabilityResult, ExecutionContext, ValidationResult } from '@oneprompt/core';

export class ReadFileCapability implements Capability {
  name = 'fs.read';
  version = '1.0.0';
  description = 'Read contents of a file';
  
  input_schema = {
    type: 'object',
    properties: {
      path: { type: 'string' },
      encoding: { type: 'string', enum: ['utf8', 'base64'], default: 'utf8' }
    },
    required: ['path']
  };
  
  output_schema = {
    type: 'object',
    properties: {
      content: { type: 'string' },
      size: { type: 'number' },
      modified: { type: 'number' }
    }
  };
  
  permissions = [
    { resource: 'filesystem', action: 'read' as const }
  ];
  
  metadata = {
    category: 'filesystem',
    tags: ['io', 'file'],
    risk_level: 'SAFE' as const,
    idempotent: true
  };
  
  validate(input: unknown): ValidationResult {
    const typed = input as { path?: string };
    
    if (!typed.path) {
      return {
        valid: false,
        errors: [{ field: 'path', message: 'Path is required' }]
      };
    }
    
    if (typeof typed.path !== 'string') {
      return {
        valid: false,
        errors: [{ field: 'path', message: 'Path must be a string' }]
      };
    }
    
    return { valid: true };
  }
  
  async execute(input: unknown, context: ExecutionContext): Promise<CapabilityResult> {
    const startTime = Date.now();
    const { path, encoding = 'utf8' } = input as { path: string; encoding?: string };
    
    try {
      // In real implementation, use fs.promises
      const fs = await import('fs').then(m => m.promises);
      
      const stats = await fs.stat(path);
      const content = await fs.readFile(path, encoding as BufferEncoding);
      
      return {
        success: true,
        output: {
          content,
          size: stats.size,
          modified: stats.mtimeMs
        },
        side_effects: [],
        duration_ms: Date.now() - startTime
      };
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'FS_READ_ERROR',
          message: String(error),
          details: { path }
        },
        side_effects: [],
        duration_ms: Date.now() - startTime
      };
    }
  }
  
  canUndo(): boolean {
    return false;
  }
}
```

### Database Query Capability

```typescript
// packages/capabilities/src/database/QueryCapability.ts

export class QueryCapability implements Capability {
  name = 'db.query';
  version = '1.0.0';
  description = 'Execute a database query';
  
  input_schema = {
    type: 'object',
    properties: {
      query: { type: 'string' },
      params: { type: 'array' }
    },
    required: ['query']
  };
  
  output_schema = {
    type: 'object',
    properties: {
      rows: { type: 'array' },
      count: { type: 'number' }
    }
  };
  
  permissions = [
    { resource: 'database', action: 'read' as const }
  ];
  
  metadata = {
    category: 'database',
    tags: ['data', 'query'],
    risk_level: 'SAFE' as const,
    idempotent: true,
    estimated_duration_ms: 500
  };
  
  validate(input: unknown): ValidationResult {
    const typed = input as { query?: string };
    
    if (!typed.query) {
      return {
        valid: false,
        errors: [{ field: 'query', message: 'Query is required' }]
      };
    }
    
    // Basic SQL injection check (simplified)
    if (typed.query.toLowerCase().includes('drop table')) {
      return {
        valid: false,
        errors: [{ field: 'query', message: 'Potentially dangerous query' }]
      };
    }
    
    return { valid: true };
  }
  
  async execute(input: unknown, context: ExecutionContext): Promise<CapabilityResult> {
    const startTime = Date.now();
    const { query, params = [] } = input as { query: string; params?: unknown[] };
    
    try {
      // Mock implementation - replace with real DB client
      const rows = await this.executeQuery(query,
